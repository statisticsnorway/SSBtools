% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate_multiple_fun.R
\name{aggregate_multiple_fun}
\alias{aggregate_multiple_fun}
\title{Wrapper to \code{aggregate}}
\usage{
aggregate_multiple_fun(
  data,
  by,
  fun,
  vars,
  ind = NULL,
  ...,
  name_sep = "_",
  seve_sep = ":",
  multi_sep = ",",
  forward_dots = FALSE,
  dots2dots = FALSE
)
}
\arguments{
\item{data}{A data frame containing data to be aggregated}

\item{by}{A data frame defining grouping}

\item{fun}{A named list of functions. These names will be used as suffixes in output variable names. Name can be omitted for one function.
A vector of function as strings is also possible. When unnamed, these function names will be used directly.
See the examples of \code{\link{fix_fun_amf}}, which is the function used to convert \code{fun}.}

\item{vars}{A named vector or list of variable names in \code{data}. The elements are named by the names of \code{fun}.
All the pairs of variable names and function names thus define all the result variables to be generated.
Parameter \code{vars} will converted to an internal standard by the function \code{\link{fix_vars_amf}}.
Thus, function names and also output variable names can be coded in different ways.
Multiple output variable names can be coded using \code{multi_sep}.
See examples and examples in \code{\link{fix_vars_amf}}.
Indices instead of variable names are allowed.}

\item{ind}{When non-NULL, a data frame of indices.
When NULL, this variable will be generated internally as \code{data.frame(ind = seq_len(nrow(data)))}.
The parameter is useful for advanced use involving model/dummy matrices.}

\item{...}{Further arguments passed to \code{aggregate}}

\item{name_sep}{A character string used when output variable names are generated.}

\item{seve_sep}{A character string used when output variable names are generated from functions of several variables.}

\item{multi_sep}{A character string used when multiple output variable names are sent as input.}
}
\value{
A data frame
}
\description{
Wrapper to \code{\link{aggregate}} that allows multiple functions and functions of several variables
}
\details{
A limitation is that the \code{...} parameters are not forwarded to the supplied functions.
When extra parameters are needed, supply instead wrapper functions where those parameters are fixed.
}
\note{
Note to developers: If \code{...} is to be handled (see details), this is probably best done by wrapper functions being generated at the start
and not by \code{...} being sent all the way through. This leads to many issues that must be dealt with,
there can be time-consuming overhead in the calculations and \code{R.utils::doCall} is no solution.
}
\examples{
z2 <- SSBtoolsData("z2")
set.seed(12)
z2$y <- round(rnorm(nrow(z2)), 2)
z <- z2[sample.int(nrow(z2), size = 20), ]
aggregate_multiple_fun(
   data = z, 
   by = z[c("kostragr", "hovedint")], 
   fun = c(sum, median = median, d1 = function(x) x[1]),    
   vars = c("ant", "y", median = "ant", median = "y", d1 = "ant")
)

# With functions as strings 
aggregate_multiple_fun(
   data = z, 
   by = z[c("kostragr", "hovedint")], 
   fun = c("sum", "median"),    
   vars = c(sum = "y", median = "ant", median = "y")
)

# with multiple outputs (function my_range)
# and with function of two variables (weighted.mean(y, ant))
my_range <- function(x) c(min = min(x), max = max(x))
aggregate_multiple_fun(
   data = z, 
   by = z[c("kostragr", "hovedint")], 
   fun = c(sum, ra = my_range, wmean = weighted.mean),    
   vars = list("ant", "y", ra = "ant", wmean  = c("y", "ant"))
)

# with specified output variable names
my_range <- function(x) c(min = min(x), max = max(x))
aggregate_multiple_fun(
   data = z, 
   by = z[c("kostragr", "hovedint")], 
   fun = c(sum, ra = my_range, wmean = weighted.mean),    
   vars = list("ant", "y", 
               `antmin,antmax` = list(ra = "ant"), 
                yWmean  = list(wmean  = c("y", "ant")))
)



 
}
